---
title: Elementary Sorts
date: 2020-05-21
sidebar: 'auto'
categories:
 - 算法
tags:
 - 算法
---
# 初级排序算法

在这儿记录三种基本的算法
1. 选择排序 Selection
2. 插入排序 Insertion
3. 希尔排序 Shell 

## 先写下一些基本的定理

1. **排序成本模型**  
在研究排序算法时,我们需要计算和比较交换的数量. 对于不交换元素的算法, 会计算**访问**数组的次数  
2. **额外的内存使用**  
排序算法的额外的内存开销和运行时间是同等重要的.排序算法可以分为两类,除了函数调用所需的栈和固定数目的实例变量之外无需额外的内存的原地算法,以及需要额外内存空间来存储另一份数组副本的其他排序算法

## 选择排序

- 按照次序将数组中最小的数字依次放在数组的左边,即将数组中最小的数字与数组第一个元素交换位置,接着在剩下的元素中找到最小的元素,放置在数组第二个元素的位置...  
- 选择排序的内循环只是在比较当前元素与目前已知的最小元素(以及当前索引加1和检查是否代码越界).交换元素的代码写在内循环之外,每次交换都能排定一个元素,因此交换的总次数是N.  
- **算法的时间效率取决于比较的次数**  

  **命题: 对于长度为N的数组,选择排序需要大约N^2/2次比较和N次循环**  
  0到N-1的任意i都会进行**一次**交换和 **N-1-i** 次比较,因此总共有 **N** 次交换以及 **(N-1)+(N-2)+...+2+1=N(N-1)/2~N^2/2** 次比较  

### 选择排序的两个鲜明的特点:

- 运行时间和输入情况无关  
  一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长
- 数据移动是最少的  
  选择排序用了N次交换,**交换次数和数组的大小是线性关系**  

```java
    public static void sort(Comparable[] a){
        int N = a.length;
        for(int i = 0; i < N; i++){
            int min = i;
            for (int j = i + 1; j < N; j++){
                if(less(a[j],a[min]))
                    min = j;
            }
            exch(a, i, min);
        }
        //less为比较方法:less(a1,a2) a1<a2则返回true
        //exch为交换方法:交换数组a中索引为i和min的元素
    }
```
![avatar](https://wx2.sbimg.cn/2020/05/30/selection.png)

## 插入排序

- 插入排序所需的时间取决于输入中元素的初始顺序  
- 对于基本有序的数组的排序很快

### 命题 1

 对于随机排列的长度为N且主键不重复的数组,平均情况下插入排序需要 ~N^2/4 次比较和 ~N^2/4次交换. 最坏情况下需要 ~N^2/2 次比较和 ~N^2/2 次交换. 最好情况下需要 N-1 次比较和 0 次交换

1. 最坏情况下对角线之下的所有元素都需要移动位置,最好情况下都不需要
2. 对于随机数组,在平均情况下每个元素都可能向后移动半个数组的长度,因此交换总数是对角线之下的元素总数的二分之一
3. 比较的总次数是交换的次数加上一个额外的项,该项为N减去被插入的元素正好是已知的最小元素的次数
4. 要求主键不重复

```java
    public static void sort(Comparable[] a){
        int N = a.length;
        for(int i = 0; i < N; i++){
            for (int j = i + 1; j > 0 && less (a[j], a[j - 1] ); j--){
                exch(a, j, j - 1);
            }
        }
    }
```
![avatar](https://wx2.sbimg.cn/2020/05/30/insertion.png)  

#### 如果数组中倒置的数量小于数组大小的某个倍数,那么这个数组是部分有序的

1. 数组中每个元素距离它最终位置都不远
2. 一个有序的大数组接一个小数组
3. 数组中只有几个元素的位置不正确  

### 命题 2

 插入排序需要的交换操作和数组中倒置的数量相同,需要的比较次数大于等于倒置的数量,小于等于倒置的数量加上数组的大小再减一

1.   每次交换都改变了两个顺序颠倒的元素的位置,即减少了一对倒置
2.   1 到 N-1 之间的每个 i 都可能需要一次额外的比较(在a[i]没有到达数组的左端时)  

### 提高插入排序的速度:

在内循环中将较大的元素都向右移动而不总是交换两个元素(达到访问数组次数减半的效果)  
### 两种数组的比较

![avatar](https://wx1.sbimg.cn/2020/05/30/bars.png)  

- 插入排序不会访问索引右侧的元素
- 选择排序不会访问索引左侧的元素
- 插入数组不会移动比被插入的元素更小的元素,它所需的比较次数平均只有选择排序的一半  

### 命题 3

对于随机排列的无重复主键的数组,插入排序和选择排序的运行时间是平方级别的,两者之比应该是一个常数

## 希尔排序
- 是基于插入排序的快速的排序算法
- 改进插入排序,交换不相邻的元素以及对数组的局部进行排序,最终用插入排序将局部的数组排序  
- 使数组中任意间隔为h的元素都是有序的,这样的数组称为 h有序数组  
![avatar](https://wx1.sbimg.cn/2020/05/30/h-sorted.png)
#### 希尔排序的两种方法:
1. 对于每个h,用插入排序将h个子数组进行独立地排序
2. 在子数组中将每个元素交换到比它大地元素之前去(将比它大地元素向右移动一格),只需要在插入排序的代码中将以移动元素的距离交换到比它大的元素之前去
#### 采用的两种递增序列:
1. 采用数组的一半长度, h = N / 2;
2. 
```java
int h = 1;
while(h < N/3)
    h = 3*h + 1;
```
取到递增序列h,每次大循环后,令 **h = h / 3**;  

```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        while (h < N / 3) {
            h = 3 * h + 1;
        }
        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h) {
                    exch(a, j, j - h);
                }
            }
            h /= 3;
        }
    }
```
![avatar](https://wx2.sbimg.cn/2020/05/30/shell.md.png)  
- 希尔排序也可以用于大型数组,对任意排序(不一定是随机的)的数组表现也很好  

- 对于上方给出的递增序列实现的算法,它的运行时间达不到平方级别,已知在最坏情况下,该算法的比较次数和N^(3/2)成正比  
  
  
##### 希尔排序的可视轨迹

![avatar](https://wx1.sbimg.cn/2020/05/30/shell-bars.md.png)  
