---
title: Priority Queues
date: 2020-05-27
sidebar: 'auto'
categories:
 - 算法
tags:
 - 算法
---
许多应用程序都需要处理有序的元素,但不一定要求它们全部有序,或是不一定要一次就将它们排序  
很多情况下我们会收集一些元素,处理当前键值组大的元素,然后再收集更多的元素,再处理当前键值最大的元素

在这种情况下,一个合适的数据结构应该支持两种操作: **删除最大元素**和**插入元素**.这种数据类型叫做优先队列

应用场景:  

- 模拟系统: 事件的键即为发生的时间,而系统需要按照时间顺序处理所有的事件
- 任务调度: 其中键值对应的优先级决定了应该首先执行哪些任务
- 数值计算: 键值代表计算错误,而我们需要按照键值指定的顺序来修正它们

## API

优先队列是一种抽象数据类型,表示了一组值和对这些值的操作  
优先队列最重要的操作就是**删除最大元素**和**插入元素**

![](https://i.loli.net/2020/11/20/mzaANkpJ4tLcY98.png)

##### 优先队列的调用示例

在某些应用场景中,输入量可能非常巨大,甚至可以认为输入是无限的  
解决问题的方法: 

1. 将输入排序然后从中找出M个最大的元素,但是我们已经说明输入将非常庞大
2. 将每个新的输入和已知的M个最大元素比较,但除非M较小,否则这种比较的代价会非常高昂

```java
public class TopM{
    public static void main(String[] args){//打印输入流中最大的M行
        int M  = Integer.parseInt(args[0]);
        MinPQ<Transation> pq = new MinPQ<Transation>(M + 1);
        while (StdIn.hasNextLine()){//为下一行输入建立一个元素并放入优先队列中
            pq.insert(new Transation(StdIn.readLine()));
            if (pq.size() > M)
                pq.delMin();		//如果优先队列中存在M+1个元素就删除最小的元素
        }
        Stack<Transation> stack = new Stack<Transation>();
        while ( !pq.isEmpty() )
            stack.push(pq.delMin());
        for (Transation t:stack)
            stdOut.println(t);
    }
}
```

当有限队列的大小超过M时就删掉其中最小的元素

## 初级实现

4种基础数据结构是实现优先队列的起点,可以通过使用有序或无序的数组和列表  

### 数组实现(无序)

insert()方法的代码和栈的push()方法完全一样. 要实现删除最大元素,可以添加一段类似于选择排序的内循环的代码,将最大元素和边界元素交换后删除它,和栈中的pop()方法的实现一样  
同时,也和栈类似,可以加入调整数组大小的代码来保证数据结构中至少含有 1/4 的元素而又永远不会溢出

### 数组实现(有序)

在insert()方法中添加代码,将所有较大的元素向右移动一格使得数组保持有序(和插入排序一样). 这样,最大的元素总在数组的一遍,优先队列的删除最大元素操作就和栈的pop()操作一样了

### 链表表示法

可以用基于链表的下压栈的代码作为基础,而后可以选择修改pop()来找到并返回最大元素  
或是修改push()来保证所有元素为**逆序**并用pop()来删除并返回链表的首元素(也就是最大元素)

使用无序列表是解决这个问题的惰性方法,我们仅仅在必要的时候才采取行动(找出最大元素)  
使用有序列表则是解决问题的积极方法,在插入元素的时候就保持列表有序,使后续操作更有效

实现栈或是队列与实现优先队列的最大不同在于对性能的要求

- 对于栈和队列,实现能够在常数时间内完成所有操作
- 对于优先队列,插入元素和删除最大元素这两个操作之一在最坏情况下需要线性时间来完成

下表为优先队列的各种实现在最坏情况下运行时间的增长数量级

| 数据结构 | 插入元素 | 删除最大元素 |
| :------: | :------: | :----------: |
| 有序数组 |    N     |      1       |
| 无序数组 |    1     |      N       |
|    堆    |  $logN$  |    $logN$    |
| 理想情况 |    1     |      1       |

![](https://i.loli.net/2020/11/20/CfZSrkXx4tncH2R.png)

## 堆的定义

==**(本节中将二叉堆简称为堆)**==

数据结构**二叉堆**能够很好的实现优先队列的基本操作

- 二叉堆: 完全二叉树或近似完全二叉树,分为最大堆和最小堆

当一棵二叉树的每个结点都大于等于它的两个子节点时,它被称为**堆有序**

### 二叉堆表示法

用指针来表示堆有序的二叉树,那么每个元素都需要三个指针来找到它的上下结点(父结点和两个子结点各需要一个).  
完全二叉树只用数组而不需要指针就可以表示,具体方法是将二叉树的结点按照层级顺序放入数组中,根结点在位置1,它的子结点在位置2和3,依次类推  

![](https://i.loli.net/2020/11/20/nYjVU3I2WB6LS8R.png)

##### 二叉堆是一组能够用堆有序的完全二叉树排序的元素,并在数组中按照层级储存(不使用数组的第一个位置)

- 在一个堆中,位置 $k$  的结点的父结点的位置为**不大于 $k/2$ 的最大整数**,而它的两个子结点的位置则分别为 $2k$ 和 $2k+1$ 
- 这样在不使用指针的情况下,可以通过计算数组的索引在树中上下移动: 从 $a[k]$ 向上一层就令 $k$ 等于 $k/2$ ,向下一层则令 $k$ 等于 $2k$ 或 $2k+1$ 

![](https://i.loli.net/2020/11/20/D4xLO9tKlsvFuUi.png)

### 命题

一棵大小为N的完全二叉树的高度为不大于 $lgN$ 的最大整数

## 堆的算法

使用长度为 N+1 的私有数组 pq[ ] 来表示一个大小为 N 的堆,不会使用 pq [ 0 ] , 堆元素放在 pq [ 1 ] 至 pq [ N ] 中.  
堆的操作会首先进行一些简单的改动,打破堆的状态,然后遍历堆并按照要求将堆的状态恢复. 这个过程称为**堆的有序化**

在堆的有序化过程中会遇到的两种情况  

1. 当某个结点的优先级上升(或是在堆底加入一个新的元素)时,需要由下至上恢复堆的数据
2. 当某个结点的优先级下降(如将根节点替换为一个较小的元素)时,需要由上至下恢复堆的顺序

### 由下至上的堆的有序化(上浮)

如果堆的有序状态因为某个结点变得比它的父结点更大而被打破,那么需要通过交换它和它的父结点来修复堆  
交换后,这个结点比它的两个子结点都大(一个是曾经的父结点,另一个比它更小,是曾经的父结点的子结点),但是这个结点仍然可能比它现在的父结点更大.  
可以通过一遍遍使用同样的方法来恢复秩序,将这个结点不断向上移动直到遇到一个更大的父结点  

- 位置为 k 的父结点的位置是 **不大于$k/2$的最大整数**

![](https://i.loli.net/2020/11/20/lX5nMAYdF7s41V8.png)

```java
private void swim(int k){
    while (k > 1 && less(k/2, k)){
        exch(k/2, k);
        k =  k / 2;
    }
}
```

### 由上至下的堆的有序化(下沉)

如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破,那么需要通过将它和它的两个子结点中较大者交换来修复堆  
不断使用方法直至子结点都比它小或是到达了堆的底部

- 由位置为 k  的结点的子结点位于 2k 和 2k+1 可以直接得到对应的代码

![](https://i.loli.net/2020/11/20/AvnkeNJw4SmxibO.png)

```java
private void sink(int k) {
   while (2*k <= N) {
      int j = 2*k;
      if (j < N && less(j, j+1)) j++;
      if (!less(k, j)) break;
      exch(k, j);
      k = j;
   }
}
```

### 实现操作

#### 插入元素

将新元素加到数组末尾,增加堆的大小并让这个新元素上浮到合适的位置(如下图左)  

#### 删除最大元素

从数组顶端删去最大的元素并将数组的最后一个元素放到顶端,减小堆的大小并让这个元素下沉到合适的位置(如下图右)

![](https://i.loli.net/2020/11/20/tzXRdyFOUBDTgcW.png)

```java
public class MaxPQ<Key extends Comparable<Key>> {
    private Key[] pq;                    //基于堆的完全二叉树
    private int N;                       // 存储于pq[1..N]中，pq[0]没有使用

    public MaxPQ(int maxN) {
        pq = (Key[]) new Comparable[maxN + 1];
    }

    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }


    public Key delMax() {
        Key max = pq[1];	//从根结点得到最大元素
        exch(1, N--);		//将其和最后一个结点交换
        pq[N + 1] = null;	//防止对象游离
        sink(1);			//恢复堆的有序性
        return max;
    }

    public void insert(Key v) {
        pq[++N] = v;
        swim(N);
    }
    
    private boolean less(int i, int j){
        
    }
    private void exch(int i, int j){
        
    }
    private void swim(int k){
        
    }
    private void sink(itn k){
        
    }
}
```

#### 命题Q

对于一个含有 N 个元素的基于堆的优先队列,插入元素操作只需不超过 $(lgN+1)$ 次比较,删除最大元素的操作需要不超过 $2lgN$ 次比较

### 多叉堆

对于数组中1至Ｎ的N个元素，位置 k 的结点大于等于位于$3k-1$, $3k$ 和 $3k+1$ 的结点,小于等于位于 **不大于 $(k+1)/3$ 的最大整数** 的结点 

### 调整数组大小

可以添加一个没有参数的构造函数,在insert()中添加将数组长度加倍的代码,在delMax()中添加将数组长度减半的代码  
当优先队列的数组大小可以调整,队列长度可以是任意值时,上个命题Q指出的对数时间复杂度上限就只是针对一般性的队列长度N而言了

### 索引优先队列

- 允许用例引用已经进入优先队列中的元素: 
  - 给每个元素一个索引

  当用例已经有了总量为N的多个元素,而且还可能同时使用了多个(平行)数组来存储这些元素信息. 此时,其他无关的用例代码可能已经在使用一个整数索引来引用这些元素了


理解这种数据结构的一个较好的方法是将它看成一个能够快速访问其中最小元素的数组  
它能够快速访问数组的一个特定子集中的最小元素(指所有被插入的元素)

#### 命题Q(续)

在一个大小为N的索引优先队列中,插入元素,改变优先级,删除和删除最小元素操作所需的比较次数和 $logN$ 成正比

含有N个元素的基于堆的索引优先队列所有操作在最坏情况下的成本  

|    操作    | 比较次数的增长数量级 |
| :--------: | :------------------: |
|  insert()  |         logN         |
|  change()  |         logN         |
| contains() |          1           |
|  delete()  |         logN         |
|   min()    |          1           |
| minIndex() |          1           |
|  delMin()  |         logN         |

### 索引优先队列用例

调用indexMinPQ的代码Multiway解决了多向归并问题:  
	将多个有序的输入流归并为一个有序的输入流

```Java
//使用优先队列的多向归并
public class Multiway{
    public static void merge(In[] streams){
        int N = streams.length;
        IndexMinPQ<String> pq = new IndexMinPQ<String>(N);
        for (int i = 0; i < N; i++)
            if (!streams[i].isEmpty())
                pq.insert(i, stream[i].readString());
        while ( !pq.isEmpty()){
            StdOut.println(pq.min());
            int i = pq.delMin();
            if ( !streams[i].isEmpty())
                pq.insert(i, streams[i].readString());
   		}
	}
	public static void main(String[] args){
        int N = args.length;
        In[] streams = new In[N];
        for (int i = 0; i < N; i++)
            streams[i] = new In(args[i]);
        merge(streams);
    }   
}
```

## 堆排序

- 我们可以把任意优先队列变成一种排序方法: 将所有元素插入一个查找最小元素的优先队列并不断重复删除最小元素
  - 用无序数组实现的优先队列相当于进行了一次选择排序
  - 用基于堆的优先队列这样做 -- **堆排序**

- 堆排序分为两个阶段: 
  - 在堆的构造阶段中,将原始数据重新组织安排进一个堆中
  - 在下沉排序阶段,从堆中按照递减顺序取出所有的元素并得到排序结果

### 堆的构造

简单的方法: 从左至右遍历数组,用swim()保证扫描指针左侧是一棵堆有序的完全数即可,可以在 $NlgN$ 时间内完成  
高效方法: 从右至左用sink()函数构造子堆, 开始只需要扫描数组中一半元素,因为可以跳过大小为1的子堆,最后在位置1上调用sink()方法 

#### 命题

用下沉操作由N个元素构造堆只需少于 2N 次比较以及少于 N 次交换

![](https://i.loli.net/2020/11/20/YBCWfugb4Dz5XEV.png)

证明: 由上图(完美二叉树情况),已知高度为k一共由 2^(h-k) 个结点, AND高度为k的结点在sink()时最多能与k个键交换,得到公式

$$ \begin{eqnarray*} h + 2(h-1) + 4(h-2) + 8(h-3) + \ldots + 2^h (0) & = & 2^{h+1} - h - 2 \\                                                & = & n - (h+1) \\                                                & \le & n \end{eqnarray*} $$

第一个等式是一个非标准和，但它是直接证明，公式成立的数学归纳法。第二个等式成立，因为高度h的完美二叉树有 2^(h+1)-1 个节点。

要证明二叉树不完美时的结果是成立的，需要多加注意。可以使用以下事实来实现:

- n个节点的二叉堆中高度为k的节点数最多为ceiln(n / 2^(k+1)),  ceiln:向正无穷大取整。

替代解决方案   
将树中节点的高度定义为以该节点为根的子树的高度。

1. 第一。观察n个节点上的二进制堆有n-1个链接(因为每个链接都是一个节点的父节点，除了根节点之外，每个节点都有一个父节点)。
2. 下沉高度为k的节点最多需要k次交换。
3. 我们将对每个节点在高度k处的k个链接收费，但不必对下沉节点时所走路径上的链接收费。相反，我们对从左-右-右-右的节点沿着路径的k链接给节点充电。例如:根节点为4个红色链接充电:蓝色节点为3个蓝色链接充电;等等。

![](https://i.loli.net/2020/11/20/JBOyP2Q3CMDG1np.png)

4. 注意，任何链接都不向一个以上的节点收费。(从根目录中仅通过正确的链接获得的链接不向任何节点收费。)
5. 因此，交换的总数最多不超过n次。由于每次交换最多有2次比较，所以比较的总数最多不超过2n次。

```java
public static void sort(Comparable[] a){
    int N = a.length;
    for (int k = N/2; k >= 1; k--)
        sink(a, k, N);
    while (N > 1){
        exch(a, 1, N--);
        sink(a, 1, N);
    }
}
private static void sink(Comparable[] pq, int k, int n) {
    while (2*k <= n) {
        int j = 2*k;
        if (j < n && less(pq, j, j+1))
            j++;
        if (!less(pq, k, j))
            break;
        exch(pq, k, j);
        k = j;
    }
}
```

![](https://i.loli.net/2020/11/20/CfGEFpsXOUyk2Jv.png)

![](https://i.loli.net/2020/11/20/X6VGPaJxv1oAYtz.png)

### 下沉排序

将堆中最大元素删除,然后放入堆缩小后数组中空出的位置(同选择排序有些类似,按照降序而非升序取出所有元素,但是所需的比较要少得多,**堆提供了一种从未排序部分找到最大元素的有效方法**)

#### 命题

将N个元素排序,堆排序只需要少于$(2NlgN+2N)$次比较,以及一半次数的交换

### 先下沉后上浮

大多数在下沉排序期间重新插入堆的元素会被直接加入到堆底  
在下沉中总是直接提升较大的子结点直至到达堆底,然后使元素上浮到正确位置,这个想法几乎可以将比较次数减少一半--接近了归并排序所需的比较次数(随机数组),这种方法需要额外的空间