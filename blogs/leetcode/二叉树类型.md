---
title: 剑指offer(二叉树类型)
sidebar: 'auto'
date: 2020-11-17
categories:
 - 算法
 - leetcode
tags:
 - Java 
 - 算法
 - leetcode
---



# 二叉树

### 重建二叉树 （剑指offer 7）

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

- 用一个`Map`保存中序遍历，其中`key`为数组元素，`value`为元素对应的下标
- 通过前序遍历可以获得`root`，在中序遍历中以`root`划分左子树和右子数
- 此问题我纠结的是参数的传递
  - 一开始想的是要想区分左右子树需要分别传递左右子树的长度到前序数组中
  - 接着发现长度可以用下标计算得来，所以传递了前序和中序以及其下标：`int[] preorder, int pre_start, int pre_end, int[] inorder, int ino_start, int ino_end`，这种传输十分繁琐
  - 接着发现pre数组的start主要用来确定root,可以直接传入; end用来判断递归结束,可以通过判断inorder数组实现一样的效果；inorder数组也没有用到，只是用到了下标。即是将`int[] preorder`声明在类中，简化后的参数传递为`int root, int left, int right`

```java
class Solution {
    /**
    简化了递归方法的参数
    pre数组的start主要用来确定root,可以直接传入; end用来判断递归结束,可以通过判断inorder数组实现一样的效果

    */
    int[] preorder;
    HashMap<Integer, Integer> dic = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        for(int i = 0; i < inorder.length; i++)
            dic.put(inorder[i], i);
        return recur(0, 0, inorder.length - 1);
    }
    /**
    简化版本
    */
    TreeNode recur(int root, int left, int right) {//参数为root，inorder中的左右下标
        if(left > right) return null;
        TreeNode node = new TreeNode(preorder[root]);
        int i = dic.get(preorder[root]);        
        node.left = recur(root + 1, left, i - 1);
        node.right = recur(root + i - left + 1, i + 1, right);
        return node;                                           
    }
    /**
    未简化版本，仅供参考
    */
        public TreeNode takeTree(int[] preorder, int ps, int pe, int[] inorder, int is, int ie, Map<Integer, Integer> map){
        if (ps > pe)    return null;
        int root = preorder[ps];
        TreeNode node = new TreeNode(root);
        if (ps == pe) {
            return node;
        } else {
            int temp = map.get(root);
            node.left = takeTree(preorder, ps + 1, ps + temp - is, inorder, is, temp - 1, map);
            node.right = takeTree(preorder, ps + temp - is + 1, pe, inorder, temp + 1, ie, map);
        }
        return node;
    }
}
```



### 树的子结构（剑指offer 26）

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)，B是A的子结构， 即 A中有出现和B相同的结构和节点值。

- 先序遍历树A中的每个结点`nodeA`，判断以`nodeA`为根的子树是否包含B树

```java
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if (A == null || B == null)  return false;
        // if (A.val == B.val){
        //     return checkSub(A, B); //这种写法会导致在判断以一个结点为根的子树（根节点相同，但子树不符合）不行时直接终止程序并返回false, 失去后面的可能正确的子树
        // }
        if (A.val == B.val && checkSub(A,B)) {
            return true;
        }
        return isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }
    
    //public boolean isSubStructure(TreeNode A, TreeNode B) {
    //    return (A != null && B != null) && (checkSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    //}将两个判断条件融入到递归代码中
    
    public boolean checkSub(TreeNode A, TreeNode B){
        if (B == null)  return true;//若B树遍历完，则说明A树中有完整的B树
        if (A == null || A.val != B.val)  return false;//A树中的B树不完整或根本没有
        return checkSub(A.left, B.left) && checkSub(A.right, B.right);//向下继续遍历
    }
}
```

### 二叉树的镜像（剑指offer 27）

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

- 二叉树的镜像，就是将每个结点的左右子树交换位置
- 递归方法：只需要将回溯的结果赋值给兄弟结点就行了，如`root.left = rec(root.right);`
- 借用栈Stack：先将根结点入栈，出栈时将其左右子结点入栈，并交换位置，直到栈为空，即交换完成

```java
//递归
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if (root == null)   return null;
        TreeNode temp = root.right;//将两个子结点中的一个暂时存储，以免值被覆盖
        root.right = mirrorTree(root.left);
        root.left = mirrorTree(temp);
        return root;
    }
}
```

```java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return null;
        Stack<TreeNode> stack = new Stack<>() {{ add(root); }};//建栈并将根结点入栈
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(node.left != null) stack.add(node.left);
            if(node.right != null) stack.add(node.right);
            TreeNode tmp = node.left;
            node.left = node.right;
            node.right = tmp;
        }
        return root;
    }
}
```

### 对称的二叉树（剑指offer 28）

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

- 在遍历过程中将左右子结点进行比较即可
- 终结条件为一方为空或值不相同，return false；两方都为空，return true；

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null)   return true;
        return mirror(root.left, root.right);
    }
    boolean mirror(TreeNode L, TreeNode R) {
        if(L == null && R == null) return true;
        if(L == null || R == null || L.val != R.val) return false;
        return mirror(L.left, R.right) && mirror(L.right, R.left);
    }
}
```



