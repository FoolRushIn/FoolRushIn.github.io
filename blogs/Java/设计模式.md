---
title: 设计模式
sidebar: 'auto'
date: 2020-07-25
categories:
 - Java
tags:
 - Java
---



**创建型模式:(关注对象的创建过程)**	

**单例模式, 工厂模式, 抽象工厂模式, 建造者模式, 原型模式**

**结构性模式:(关注对象和类的组织)**

**适配器模式, 桥接模式, 装饰模式, 组合模式, 外观模式, 享元模式, 代理模式**

**行为型模式(关注系统中对象之间的相互交互, 研究系统在运行时对象之间的相互通信和协作, 进一步明确对象的职责, 共有11中模式):**

**模板方法模式,** **命令模式****, 迭代器模式, 观察者模式, 中介者模式, 备忘录模式,** **解释器模式****, 状态模式, 策略模式, 职责链模式,** **访问者模式**

![img](https://wx1.sbimg.cn/2020/09/12/9UIn7.md.png)

## **创建型模式:**

### **单例模式:**

**核心作用:	保证一个类只有一个实例, 并且提供一个访问该实例的全局访问点**

![img](https://wx1.sbimg.cn/2020/09/12/9iCCn.md.png)

**单例模式的优点：**

由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决

单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理

常见的五种单例模式实现方式：

**主要：**

- 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）
- 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）

其他：

- 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）
- 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)
- 枚举单例(线程安全，调用效率高，不能延时加载)

**饿汉式实现（单例对象立即加载）**

```java
public class SingletonDemo02 { 
    private static  /*final*/   SingletonDemo02 s = new SingletonDemo02(); 
    
    private SingletonDemo02(){ }//私有化构造器 
    
    public static /*synchronized*/ SingletonDemo02 getInstance(){ 
        return s; 
    } 
}
```

```java
public class Client { 
    public static void main(String[] args) { 
        SingletonDemo02 s = SingletonDemo02.getInstance(); 	
        SingletonDemo02 s2 = SingletonDemo02.getInstance(); 
        System.out.println(s==s2); //结果为true 
    } 
}
```

 饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字

**懒汉式实现（单例对象延迟加载）**

```java
public class SingletonDemo01 {   
    private static SingletonDemo01 s;     
    private SingletonDemo01(){} //私有化构造器    
    public static synchronized SingletonDemo01 getInstance(){   
        if(s==null){                  
            s = new SingletonDemo01();      
        }            
        return s;    
    }
}
```

要点：

- lazy load!                
- 延迟加载，  懒加载！  真正用的时候才加载！

问题：

资源利用率高了。但是，每次调用getInstance()方法都要同步，并发效率较低。

**双重检测锁实现**

**这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，只有第一次才同步创建了以后就没必要了。**

```java
public class Singleton6 { 
    // volatile声明作用即是内存变量共享的作用  
    private static volatile Singleton6 instance;  
    // 构造器私有化    
    private Singleton6() {}    
    // 提供公有的获取方法  
    public static Singleton6 getInstance() {   
        if (instance == null) {           
            synchronized (Singleton6.class) {      
                if (instance == null) {     
                    instance = new Singleton6();           
                }          
            }      
        }      
        return instance;   
    }
}
```

**问题：**

- **由于编译器优化原因和JVM底层内部模型原因，偶尔会出问题。不建议使用。**

**静态内部类实现方式(也是一种懒加载方式)**

```java
public class SingletonDemo04 {
    private static class SingletonClassInstance { 
        private static final SingletonDemo04 instance = new SingletonDemo04(); 
    }  	 
    public static SingletonDemo04 getInstance() {  
        return SingletonClassInstance.instance; 
    }  	
    private SingletonDemo04() {  
    } 
}
```

**要点：**

1. 外部类没有static属性，则不会像饿汉式那样立即加载对象。
2. 外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类。
3. 只有真正调用getInstance(),才会加载静态内部类。加载类时是线程 安全的。 instance是static final类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.
4. 兼备了并发高效调用和延迟加载的优势！

**问题：**

1. **反射可以破解上面几种(不包含枚举式)实现方式！（可以在构造方法中手动抛出异常控制）**
2. **反序列化可以破解上面几种((不包含枚举式))实现方式！**
   1. 可以通过定义readResolve()防止获得不同对象。
   2. 反序列化时，如果对象所在类定义了readResolve()，（实际是一种回调），定义返回哪个对象。

**使用枚举实现单例模式**

```java
public enum SingletonDemo05 {   
    /**    
    * 定义一个枚举的元素，它就代表了Singleton的一个实例。 
    */  
    INSTANCE;   
    /**    
    * 单例可以有自己的操作  
    */  
    public void singletonOperation(){   
        //功能处理   
    }
}

public static void main(String[] args) {
    SingletonDemo05  sd = SingletonDemo05.INSTANCE; 
    SingletonDemo05  sd2 = SingletonDemo05.INSTANCE; 
    System.out.println(sd==sd2); 
}
```

**优点：**

- 实现简单
- 枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！

缺点：

- 无延迟加载
- 常见的五种单例模式在多线程环境下的效率测试

大家只要关注相对值即可。在不同的环境下不同的程序测得值完全不一样

| **饿汉式**   | **22ms** |
| ------------ | -------- |
| 懒汉式       | 636ms    |
| 静态内部类式 | 28ms     |
| 枚举式       | 32ms     |
| 双重检查锁式 | 65ms     |

**CountDownLatch**

**同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。**

1. countDown()  当前线程调此方法，则计数减一(建议放在 finally里执行)
2. await()，   调用此方法会一直阻塞当前线程，直到计时器的值为0

**常见的五种单例模式实现方式**

主要：

1. 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）
2. 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）

其他：

1. 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）
2. 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)
3. 枚举式(线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化漏洞！)

**如何选用?**

- 单例对象  占用  资源 少，不需要  延时加载：
- 枚举式 好于 饿汉式
- 单例对象  占用  资源 大，需要 延时加载：
- 静态内部类式 好于 懒汉式

### **工厂模式：**

**实现了创建者和调用者的分离。**

工厂模式分为简单工厂模式，工厂方法模式和抽象工厂模式，它们都属于设计模式中的创建型模式。其**主要功能都是帮助我们把对象的实例化部分抽取了出来，目的是降低系统中代码耦合度**，并且增强了系统的扩展性。

详细分类：

**简单工厂模式:**

- **用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）**

**工厂方法模式:**

- **用来生产同一等级结构中的固定产品。（支持增加任意产品）**  

**抽象工厂模式:**

- **用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）** 

面向对象设计的基本原则：

- OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭。		
- DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程。	
- LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信。

**核心本质：**

**实例化对象，用工厂方法代替new操作。**

**将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。**

**简单工厂模式要点：**[**https://www.cnblogs.com/zailushang1996/p/8601808.html**](https://www.jianshu.com/p/d951ac56136e)

简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。

对于增加新产品无能为力！不修改代码的话，是无法扩展的。

**工厂方法模式要点：**

为了避免简单工厂模式的缺点，不完全满足OCP。

工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。

工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。

### **抽象工厂模式**

用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） 

 抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生	需要的对象是一种非常好的解决方式。

![img](https://wx2.sbimg.cn/2020/09/12/9iN8h.md.png)

根据实例可以描述为： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例。.

### **建造者模式**

**本质：**

1. 分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。
2. 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。

**原型模式prototype**

1. 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
2. 就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点
3. 优势有：效率高(直接克隆，避免了重新执行构造过程步骤) 。
4. 克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后，再修改克隆对象的值。

### **原型模式实现：**

1. Cloneable接口和clone方法
2. Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在Java中提供了clone()方法替我们做了绝大部分事情。

**浅克隆存在的问题**

被复制的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的	对象。

**深克隆如何实现?**

深克隆把引用的变量指向复制过的新对象，而不是原有的被引用的对象。

深克隆：让已实现Clonable接口的类中的属性也实现Clonable接口

基本数据类型和String能够自动实现深度克隆（值的复制）

![img](https://wx1.sbimg.cn/2020/09/12/9ilpM.md.png)

## **结构型模式：**

**核心作用：**

**是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。**

**分类：**

**适配器模式、代理模式、桥接模式、装饰模式、组合模式、外观模式、享元模式**

| 代理模式 | 为真实对象提供一个代理，从而控制对真实对象的访问             |
| -------- | ------------------------------------------------------------ |
| 适配模式 | 使原本由于接口不兼容不能一起工作的类可以一起工作             |
| 桥接模式 | 处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。 |
| 组合模式 | 将对象组合成树状结构以表示”部分和整体”层次结构，使得客户可以统一的调用叶子对象和容器对象 |
| 装饰模式 | 动态地给一个对象添加额外的功能，比继承灵活                   |
| 外观模式 | 为子系统提供统一的调用接口，使得子系统更加容易使用           |
| 享元模式 | 运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率 |

### **适配器adapter模式**

**什么是适配器模式?**

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

**模式中的角色**

1. 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。
2. .需要适配的类（Adaptee）：需要适配的类或适配者类。
3. 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。　

**适配器模式使用**

java适配器模式有两种，类适配器和对象适配器

**类适配器demo**

类适配器主要是使用继承的方式连接两个接口

**对象适配器demo**

上面的类适配器用的是“继承”的方式去连接，这里的对象适配器用的是“组合”的方式。

### **代理模式(Proxy  pattern)：**

**核心作用：**

**通过代理，控制对对象的访问！**

**可以详细控制访问某个（某类）对象的方法**，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即：AOP的微观实现！）

**AOP(Aspect  Oriented  Programming面向切面编程)的核心实现机制！**

**核心角色：**

**抽象角色:**

定义代理角色和真实角色的公共对外方法

**真实角色:**

1. 实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。
2. 关注真正的业务逻辑！

**代理角色:**

1. 实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
2. 将统一的流程控制放到代理角色中处理！

![img](https://wx2.sbimg.cn/2020/09/12/9irga.png)

**应用场景：**

**安全代理：**屏蔽对真实角色的直接访问。

**远程代理：**通过代理类处理远程方法调用(RMI)

**延迟加载：**先加载轻量级的代理对象，真正需要再加载真实对象。

比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。

**分类：**

**静态代理(静态定义代理类)**

**动态代理(动态生成代理类)**

1. JDK自带的动态代理
2. javaassist字节码操作库实现
3. CGLIB
4. ASM(底层使用指令，可维护性较差)

**JDK自带的动态代理:**

**java.lang.reflect.Proxy**

作用：动态生成代理类和对象

**java.lang.reflect.InvocationHandler(处理器接口)**

1. 可以通过invoke方法实现对真实角色的代理访问。
2. 每次通过Proxy生成代理类对象对象时都要指定对应的处理器对象

**常用术语：**

- 切面（Aspect）：其实就是共有功能的实现。

- 通知（Advice）：是切面的具体实现。

- 连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。

- 切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。

- 目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象

- 代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。

- 织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。


**开源的AOP框架:**

**AspectJ**

### **桥接模式(bridge)**

**场景**

商城系统中常见的商品分类，以电脑为类，如何良好的处理商品分类销售的问题?

我们可以用多层继承结构实现下图的关系。

![img](https://wx1.sbimg.cn/2020/09/12/9iOaR.md.png)

**问题：**

**扩展性问题(类个数膨胀问题)：**

如果要增加一个新的电脑类型:智能手机，则要增加各个品牌下面的类。

如果要增加一个新的品牌，也要增加各种电脑类型的类。

**违反单一职责原则：**

一个类：联想笔记本，有两个引起这个类变化的原因

**桥接模式核心要点：**

处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。

![img](https://wx1.sbimg.cn/2020/09/12/9iyQK.md.png)

**桥接模式实际开发中应用场景**

- JDBC驱动程序
  - AWT中的Peer架构

- 银行日志管理：

  - 格式分类：操作日志、交易日志、异常日志
  - 距离分类：本地记录日志、异地记录日志

- 人力资源系统中的奖金计算模块：

  - 奖金分类：个人奖金、团体奖金、激励奖金。
  - 部门分类：人事部门、销售部门、研发部门。
- OA系统中的消息处理：

  - 业务类型：普通消息、加急消息、特急消息
  - 发送消息方式：系统内消息、手机短信、邮件

### **组合模式(composite)**

**合成模式属于对象的结构模式，有时又叫做“部分——整体”模式。合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。**

**使用组合模式的场景：**

**把部分和整体的关系用树形结构来表示**，从而使客户端可以使用统一的方式处理部分对象和整体对象。

**组合模式核心：**

**抽象构件(Component)角色:** 		定义了叶子和容器构件的共同点

**叶子(Leaf)构件角色：**			无子节点

**容器(Composite)构件角色：**		有容器特征，可以包含子节点

![img](https://wx1.sbimg.cn/2020/09/12/9iFOT.md.png)

**组合模式工作流程分析：**

组合模式为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。

当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行。其中，使用了递归调用的机制对整个结构进行处理。

**开发中的应用场景：**

- 操作系统的资源管理器
- GUI中的容器层次图

- XML文件解析
- OA系统中，组织结构的处理
- Junit单元测试框架
  - 底层设计就是典型的组合模式，TestCase(叶子)、TestUnite(容器)、Test接口(抽象)

**Junit单元测试框架底层设计**

底层设计就是典型的组合模式，TestCase(叶子)、TestUnite(容器)、Test接口(抽象)

![img](https://wx2.sbimg.cn/2020/09/12/9ifPw.md.png)

### **装饰模式(decorator)**

**职责：**

1. 动态的为一个对象增加新的功能。
2. 装饰模式是一种用于代替继承的技术，**无须通过继承增加子类就能扩展对象的新功能**。使用对象的关联关系代替继承关系，更加灵活，**同时避免类型体系的快速膨胀。**

**实现细节：**

**Component抽象构件角色：**

真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。

**ConcreteComponent 具体构件角色(真实对象)：**

io流中的FileInputStream、FileOutputStream

**Decorator装饰角色：**

持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。

**ConcreteDecorator具体装饰角色：**

负责给构件对象增加新的责任。

![img](https://wx1.sbimg.cn/2020/09/12/9n41o.md.png)



<img src="https://wx2.sbimg.cn/2020/09/12/9n58l.md.png" alt="img" />

**开发中使用的场景：**

1. IO中输入流和输出流的设计
2. Swing包中图形界面构件功能
3. Servlet API 中提供了一个request对象的Decorator设计模式的默认实现类	HttpServletRequestWrapper，HttpServletRequestWrapper 类，增强了request对象的功能。
4. Struts2中，request，response,session对象的处理

**IO流实现细节：**

**Component抽象构件角色：**

 io流中的InputStream、OutputStream、Reader、Writer

**ConcreteComponent 具体构件角色：**

io流中的FileInputStream、FileOutputStream

**Decorator装饰角色：**

持有一个抽象构件的引用：io流中的FilterInputStream、FilterOutputStream

**ConcreteDecorator具体装饰角色：**

负责给构件对象增加新的责任。Io流中的BufferedOutputStream、BufferedInputStream等。

**总结：**

**装饰模式（Decorator）也叫包装器模式（Wrapper）**

**装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类。**

**优点:**

扩展对象功能，比继承灵活，不会导致类个数急剧增加

可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象

具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类。

**缺点:**

产生很多小对象。大量小对象占据内存，一定程度上影响性能。

装饰模式易于出错，调试排查比较麻烦。

**装饰模式和桥接模式的区别：**

两个模式都是为了解决过多子类对象问题。但他们の诱因不一样。桥模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。

### **外观模式 facade**

**迪米特法则(最少知识原则)：**

一个软件实体应当尽可能少的与其他实体发生相互作用。

![img](https://wx1.sbimg.cn/2020/09/12/9nXp1.md.png)

**外观模式核心：**

为子系统提供统一的入口。封装子系统的复杂性，便于客户端调用。

![img](https://wx1.sbimg.cn/2020/09/12/9npa8.md.png)

### **享元模式(FlyWeight)**

**场景：**

内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。

**核心：**

**享元模式以共享的方式高效地支持大量细粒度对象的重用**

**享元对象能做到共享的关键是区分了内部状态和外部状态。**

内部状态：可以共享，不会随环境变化而改变

外部状态：不可以共享，会随环境变化而改变

![img](https://wx1.sbimg.cn/2020/09/12/9n2Am.md.png)

**享元模式实现：**

**FlyweightFactory享元工厂类:**

创建并管理享元对象，享元池一般设计成键值对

**FlyWeight抽象享元类:**

通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。

**ConcreteFlyWeight具体享元类:**

为内部状态提供成员变量进行存储

**UnsharedConcreteFlyWeight非共享享元类:**

不能被共享的子类可以设计为非共享享元类

![img](https://wx2.sbimg.cn/2020/09/12/9nC7U.md.png)

**享元模式开发中应用的场景：**

1. 享元模式由于其共享的特性，可以在任何“池”中操作，比如：线程池、数据库连接池。
2. String类的设计也是享元模式

**优点:**

1. 极大减少内存中对象的数量
2. 相同或相似对象内存中只存一份，极大的节约资源，提高系统性能
3. 外部状态相对独立，不影响内部状态

**缺点:**

1. 模式较复杂，使程序逻辑复杂化
2. 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间。

## **行为型模式**

### **责任链模式:**

**定义：**

将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象。

**场景：**

打牌时，轮流出牌

接力赛跑

大学中，奖学金审批

公司中，公文审批

**添加新的处理对象：**

由于责任链的创建完全在客户端，因此新增新的具体处理者对原有类库没有任何影响，只需添加新的类，然后在客户端调用时添加即可。符合开闭原则。

**案例：**

我们可以在请假处理流程中，增加新的“副总经理”角色，审批大于等于10天，小于20天的请假。审批流程变为：

1. 如果请假天数小于3天，主任审批
2. 如果请假天数大于等于3天，小于10天，经理审批
3. 大于等于10天，小于20天的请假，副总经理审批
4. 如果大于等于20天，小于30天，总经理审批
5. 如果大于等于30天，提示拒绝

**链表方式定义职责链(上一个案例)**

**非链表方式实现职责链**

通过集合、数组生成职责链更加实用！实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以使用链表方式定义COR链就很困难。

**开发中常见的场景：**

Java中，异常机制就是一种责任链模式。一个try可以对应多个catch，当第一个catch不匹配类型，则自动跳到第二个catch.

Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理采用观察者模式。

Servlet开发中，过滤器的链式处理

Struts2中，拦截器的调用也是典型的责任链模式

### **迭代器模式 iterator**

**场景：**

**提供一种可以遍历聚合对象的方式。又称为：游标cursor模式**

**聚合对象：存储数据**

**迭代器：遍历数据**

**结构：**

聚合对象：存储数据

迭代器：遍历数据

![img](https://wx1.sbimg.cn/2020/09/12/9noo4.md.png)

将迭代器作为内部类, 可以直接使用外部类的属性

**基本案例：**

- 实现正向遍历的迭代器

- 实现逆向遍历的迭代器


**开发中常见的场景：**

JDK内置的迭代器(List/Set)

### **中介者模式 Mediator**

**场景(中介大家熟悉吗?房产中介?)：**

- 假如没有总经理。下面三个部门：财务部、市场部、研发部。财务部要发工资，让大家核对公司需要跟市场部和研发部都通气；市场部要接个新项目，需要研发部处理技术、需要财务部出资金。市场部跟各个部门打交道。  虽然只有三个部门，但是关系非常乱。
- 实际上，公司都有总经理。各个部门有什么事情都通报到总经理这里，总经理再通知各个相关部门。

这就是一个典型的“中介者模式”总经理起到一个中介、协调的作用

**核心：**

如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系及其复杂，这些对象称为“同事对象”

我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网络结构化解为如下的星形结构。

![img](https://wx2.sbimg.cn/2020/09/12/9n31Y.md.png)

![img](https://wx1.sbimg.cn/2020/09/12/9n6EA.md.png)

**中介者模式的本质：**

解耦多个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互关系

**开发中常见的场景：**

1. MVC模式(其中的C，控制器就是一个中介者对象。M和V都和他打交道)
2. 窗口游戏程序，窗口软件开发中窗口对象也是一个中介者对象
3. 图形界面开发GUI中，多个组件之间的交互，可以通过引入一个中介者对象来解决，可以是整体的窗口对象或者DOM对象
4. Java.lang.reflect.Method#invoke()

### **命令模式 command**

**介绍：**

命令模式：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。也称之为：动作Action模式、事务transaction模式

**结构：**

**-- Command抽象命令类**

**-- ConcreteCommand具体命令类**

**-- Invoker调用者/请求者**

请求的发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的execute()，间接调用接收者的相关操作。

**-- Receiver接收者**

1. 接收者执行与请求相关的操作，具体实现对请求的业务处理。
2. 未抽象前，实际执行操作内容的对象。

**-- Client客户类**

在客户类中需要创建调用者对象、具体命令类对象，在创建具体命令对象时指定对应的接收者。发送者和接收者之间没有直接关系，都通过命令对象间接调用。

![img](https://wx2.sbimg.cn/2020/09/12/9n7TG.md.png)

**开发中常见的场景：**

1. Struts2中，action的整个调用过程中就有命令模式。
2. 数据库事务机制的底层实现
3. 命令的撤销和恢复

### **解释器模式 Interpreter**

**解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。**

![img](https://wx1.sbimg.cn/2020/09/12/9nzHK.md.png)

**（1）抽象表达式(Expression)角色：**声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。

**（2）终结符表达式(Terminal Expression)角色：**实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。

**（3）非终结符表达式(Nonterminal Expression)角色：**文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+"就是非终结符，解析“+”的解释器就是一个非终结符表达式。

**（4）环境(Context)角色：**这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。

 

### **访问者模式 Visitor**

**封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作**

![img](https://wx2.sbimg.cn/2020/09/12/9nwAI.md.png)

**抽象访问者(Visitor)角色：**声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。

**具体访问者(ConcreteVisitor)角色：**实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。

**抽象节点(Node)角色：**声明一个接受操作，接受一个访问者对象作为一个参数。

**具体节点(ConcreteNode)角色：**实现了抽象节点所规定的接受操作。

**结构对象(ObjectStructure)角色：**有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。

### **策略模式**

**策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。**

**场景：**

某个市场人员接到单后的报价策略(CRM系统中常见问题)。报价策略很复杂，可以简单作如下分类：

- 普通客户小批量报价

- 普通客户大批量报价

- 老客户小批量报价

- 老客户大批量报价


具体选用哪个报价策略，这需要根据实际情况来确定。这时候，我们采用策略模式即可。

![img](https://wx1.sbimg.cn/2020/09/12/9nt4R.md.png)

**本质:**	

**分离算法, 选择实现**

**模板方法模式 template method**

**知道骨架, 但是不知道具体细节**

**场景：**

客户到银行办理业务：

1. 取号排队
2. 办理具体现金/转账/企业/个人/理财业务
3. 给银行工作人员评分

### **模板方法模式介绍：**

**模板方法模式是编程中经常用得到模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。**

**核心：**

处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。因此，我们采用工厂方法模式，将这个节点的代码实现转移给子类完成。**即****：处理步骤父类中定义好，具体实现延迟到子类中定义**

![img](https://wx2.sbimg.cn/2020/09/12/9nqva.md.png)

**什么时候用到模板方法模式：**

实现一个算法时，整体步骤很固定。但是，某些部分易变。易变部分可以抽象成出来，供子类实现。

### **状态模式 state**

**场景：**

**电梯的运行**

维修、正常、自动关门、自动开门、向上运行、向下运行、消防状态

**红绿灯**

红灯、黄灯、绿灯

**企业或政府系统**

公文的审批状态-->报销单据审批状态-->假条审批

**网上购物时，订单的状态**

下单-->已付款-->已发货-->送货中-->已收货

![img](https://wx1.sbimg.cn/2020/09/12/9n1sM.md.png)

**核心：**

用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题

**结构：**

**Context环境类:**

环境类中维护一个State对象，他是定义了当前的状态。

**State抽象状态类:**

**ConcreteState具体状态类:**

每一个类封装了一个状态对应的行为

![img](https://wx1.sbimg.cn/2020/09/12/9nLEn.md.png)

### **观察者模式 Observer**

**场景：**

聊天室程序的创建。服务器创建好后，A,B,C三个客户端连上来公开聊天。A向服务器发送数据，服务器端聊天数据改变。我们希望将这些聊天数据分别发给其他在线的客户。也就是说，每个客户端需要更新服务器端得数据。

网站上，很多人订阅了”java主题”的新闻。当有这个主题新闻时，就会将这些新闻发给所有订阅的人。

大家一起玩CS游戏时，服务器需要将每个人的方位变化发给所有的客户。

**上面这些场景，我们都可以使用观察者模式来处理。我们可以把多个订阅者、客户称之为观察者； 需要同步给多个订阅者的数据封装到对象中，称之为目标。**

**核心：**

![img](https://wx1.sbimg.cn/2020/09/12/9nsoj.md.png)

**JAVASE提供了java.util.Observable和java.util.Observer来实现观察者模式**

### **备忘录模式 memento**

**场景：**

1. 录入大批人员资料。正在录入当前人资料时，发现上一个人录错了，此时需要恢复上一个人的资料，再进行修改。
2. Word文档编辑时，忽然电脑死机或断电，再打开时，可以看到word提示你恢复到以前的文档
3. 管理系统中，公文撤回功能。公文发送出去后，想撤回来。

**核心**

就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。

**结构：**

源发器类Originator

备忘录类Memento

负责人类CareTaker

**负责人类**

负责保存好的备忘录对象。

可以通过增加容器，设置多个“备忘点”

**备忘点较多时：**

将备忘录压栈

```java
public class CareTaker { 
    private Memento memento; 
    private Stack<Memento> stack = new Stack<Memento>(); 
}
```

将多个备忘录对象，序列化和持久化
