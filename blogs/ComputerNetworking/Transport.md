---
title: 运输层
sidebar: 'auto'
date: 2020-07-08
categories:
 - 计算机网络
tags:
 - 计算机网络
---
# 运输层

## 运输层服务

运输层最低限度必须提供一种复用/分解服务,以便在网络层与正确的应用级进程之间传递数据

运输层协议为运行在不同主机上的应用进程之间提供了**通信逻辑**功能   
运输层协议是在端系统中而不是在路由器中实现的。

- 因为只有端系统中才有完整的因特网五层协议，路由器只实现了物理层、数据链路层和网络层。
- 网络路由器仅作用于该数据报的网络层字段
  - 不检查封装在改数据报的运输层报文段的字段

网络应用程序可以使用多种的运输层协议. 例如, 因特网又两种协议: TCP和UDP. 每种协议都能为调用的应用程序提供一组不同的运输层服务

### 运输层和网络层之间的关系

- 网络层提供了**主机之间**的逻辑通信, 运输层为运行在不同主机上的**进程之间**提供了逻辑通信
- 运输层协议只工作在端系统中,将来自应用进程的报文移动到网络边缘(网络层),或反过来
- 运输层协议提供的服务受制于底层网络层协议的服务模型
  - 如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证,运输层协议也无法为进程之间发送的应用程序报文提供时延或带宽保证
- 即使底层网络协议不能在网络层提供相应的服务,运输层协议也能提供某些服务

![](https://wx1.sbimg.cn/2020/08/02/Pb4CA.md.jpg)

### 运输层概述

==将TCP和UDP的分组统称为报文段,将网络层分组称为数据报==

因特网网络层协议:IP(不可靠服务)

- IP为主机之间提供了逻辑通信
- IP的服务模型是**尽力而为交付服务**
  - 尽力在通信的主机之间交付报文段,但是不做任何确保
    - 不确保报文段的交付,不确保报文段的按序交付,不保证报文段中数据的完整性
- 每台主机至少有一个网络层协议,即一个IP地址

运输层协议 TCP和UDP提供的服务模型: 

- 将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务
- 将主机间交付扩展到进程间交付被称为**运输层的多路复用**与**多路分解**

TCP为应用程序提供了几种附加服务

1. 提供可靠数据传输。通过使用流量控制、序号、确认和定时器来确保
2. 提供拥塞控制

TCP提供更多服务，必然会比UDP复杂。

## 多路复用和多路分解

将主机间交付扩展到进程间交付被称为**运输层的多路复用**与**多路分解**

考虑一个具体的场景，一台计算机正在运行4个进程：2个Telnet进程、一个FTP进程和一个HTTP进程。这台计算机的运输层从底层的网络层接收数据时，它需要将所接收到的数据定向到这4个进程中的一个。

一个进程会有一个或多个套接字，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。由于在任一时刻，在接收主机上可能有不止一个套接字，所以每个套接字都会有唯一的标识符。（同时，标识符的格式取决于它是UDP还是TCP套接字。）

所以，问题转换成接收主机怎样将一个到达的运输层报文段定向到适当的套接字。为了完成这个任务，每个运输层报文段中会有几个字段。在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。

- **多路分解：**将运输层报文段中的数据交付到正确的套接字的工作
- **多路复用：**在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（用于在以后分解）从而生成报文段，然后将报文段传递到网络层的工作

### 运输层多路服用的要求

1. 套接字有唯一标识符
2. 每个报文段有特殊字段来指示该报文段所要交付到的套接字

![特殊字段](https://wx1.sbimg.cn/2020/08/02/PbPrk.md.png)

如上图,特殊字段是**源端口号字段**和**目的端口号字段**. (端口号是一个16比特的数,大小在0 ~ 65535. 0 ~1023范围的端口号是周知端口号，是受限制的，它们保留给诸如HTTP（端口号80）和FTP（端口号21）之类的周知应用层协议来使用。)

**常用服务及其端口号**

![](https://wx2.sbimg.cn/2020/08/02/Pb3Cn.md.png)

**运输层实现分解服务:**

在主机上的每个套接字能够分配一个端口号,当报文段到达主机时,运输层检查报文段中的目的端口号,并将其定向到相应的套接字. 然后报文段中的数据通过套接字进入其所连接的进程 (UDP基本是这样做的, TCP的多路复用和多路分解更加复杂)

### 无连接的多路复用与多路分解(UDP)

如果应用程序开发者所编写的代码实现的是一个“周知协议”的服务器端，那么开发者就必须为其分配一个相应地周知端口号。通常，应用程序的客户端让运输层自动地（并且是透明地）分配端口号，而服务器端则分配一个特定的端口号。

==**一个UDP套接字由一个二元组来全面标识，该二元组包含一个目的IP地址和一个目的端口号。**==  
因此，如果两个UDP报文段有不同的源IP地址和/或源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。

### 面向连接的多路复用与多路分解(TCP)

==**一个TCP套接字由一个四元组来标识。包含源IP地址，源端口号，目的IP地址，目的端口号。**==
 因此，当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向（分解）到相应地套接字。

**特别与UDP不同的是，具有不同源IP地址或源端口号，但具有相同目的IP地址或目的端口号的两个到达TCP报文段将被定向到两个不同的套接字；除非TCP报文段携带了初始创建连接的请求。**

- 首先解释分号前一句。因为TCP是面向连接的，需要经过“三次握手”建立连接。服务器每收到一个客户进程的连接请求，都要建立一个新的连接——包括创建一个新的服务器进程与客户进程通信，与一个相应的套接字。
  - 更具体地说，客户进程1与服务器的TCP连接，客户进程2与服务器的TCP连接是不同的两个TCP连接。客户进程1会与服务器进程1进行TCP连接，客户进程2会与服务器进程2进行TCP连接，这2个服务器进程也需要有2个不同的套接字。有n个客户进程就至少需要n个套接字。**所以源不同，就会被定向到不同的套接字。**
- 分号后一句。服务器进程在TCP连接中，会有一个“欢迎套接字”用于建立与客户进程之间的TCP连接。这个“欢迎套接字”是唯一的，仅在“三次握手”时会收到报文。所以如果当两个客户进程同时发出请求与服务器进程建立连接的报文段，它们会被定向到同一个套接字，即“欢迎套接字”。

### Web服务器与TCP

连接套接字与进程之间并非总是有着一一对应的关系, 事实上，当今高性能的Web服务器通常只使用一个进程，但是会为每个新的客户连接创建一个具有新连接套接字的新线程(线程可以看作一个轻量级的子进程)。

## 无连接运输 UDP

使用UDP的应用程序差不多就是直接与IP打交道.   
使用UDP时,在发送报文段之前,发送方和接收方的运输层实体之间没有握手. 正因如此,UDP被称为是**无连接**的

**UDP的优势**

-  应用层能更好发控制要发送的数据和发送时间。
-  无须建立连接。
-  无连接状态。
-  分组首部开销小。

### UDP报文段结构

![](https://wx2.sbimg.cn/2020/08/04/PfGo8.md.png)

UDP报文段结构由RFC 768定义，UDP首部只有4个字段，每个字段由两个字节组成。　　

- 源端口号： 本机（客户端）的应用程序的套接字所对应的端口号，服务器端可利用此端口号向客户端发送数据。
- 目的端口号： 服务端上的应用进程的套接字所对应的端口号，例如HTTP服务器的80端口。
- 长度：指明了首部和数据部分的UDP报文段的总长度，单位为字节，即首部+数据。
- 检验和： 提供了差错检测功能，即检验和用于确定当UDP报文段从源到达目的时，其中的比特是否发生了改变。

### UDP检验和

- 发送方
  - 将段的内容视为16-bit整数
  - 校验和计算：计算所有整数的和，进位加在和的后面，将得到的值按位求反，得到校验和
  - 发送方将校验和放入校验和字段
- 接收方
  - 计算所得到段的检验和，并将其余检验和字段进行比较。
  - 如果不相等，则检验出错误，但若相等也可能有错误。

## 可靠数据传输原理

借助于可信通道,传输数据比特不会受到损坏(由0变为1,或相反)或丢失,并且所有的数据都按照其发送顺序进行交付. 实现这种服务抽象是**可靠数据传输协议**

### 构造可靠数据传输协议

　　**1.经完全可靠信道的可靠数据传输 :rdt 1.0**

　　有限状态机(FSM) 可以表示有限个状态及在这些状态之间的转移和动作等行为的数学模型，下图即表示发送方和接收方的有限状态机，底层信道是完全可靠的，发送方和接收方有各自的FSM，每个FSM都只有一个状态。

　　（图解：FSM描述中的箭头指示了协议从一个状态变迁到另一个状态。引起变迁的事件显示在横线的上方，事件发生时所采用的运动显示在横线的下方。FSM的初始状态用虚线表示。）

　　![img](https://img2018.cnblogs.com/blog/226988/201906/226988-20190608160537636-82557925.png)

- 因为信道可靠，接收方也不需要提供任何反馈信息给发送方
- 假定了接收方接收数据的速率能够与发送方发送数据的速率一样快，所以接收方也没有必要请求发送方慢一点发送。

　　**2.经具有比特差错信道的可靠数据传输: rdt2.0**

　　下图为rdt 2.0 的有限状态机描述图，该数据传输协议（自动重传请求协议）采用了**==差错检测==**、**==肯定确认==**与**==否定确认==**。

　　![img](https://img2018.cnblogs.com/blog/226988/201906/226988-20190608161751788-910745346.png)

- 在发送端

  左边的初始状态

  中，发送端协议正等待来自较高层传下来的数据。当触发 

  ```
  rdt_send(data)
  ```

   事件时：

  - 通过 `sndpkt = make_pkt(data, checksum)` 产生一个包含待发送数据且带有校验和的分组
  - 然后将该分组通过 `udt_send(sndpkt)` 发送到信道中

- 执行完上述的两个动作后，发送端的状态变迁为“等待接收接收端的 ACK 或 NAK 分组”。即转变为

  右侧状

  态，接下来根据接收端的响应不同会有不同的变迁方案：

  - 如果收到了一个 ACK 分组（`rdt_rcv(rcvpkt) && isACK(rcvpkt)`），那么发送方知道最近一个分组已经被正确接收，因此协议返回左边状态，继续等待下一次由较高层传下来的数据发送请求
  - 如果收到了一个 NAK 分组（`rdt_rcv(rcvpkt) && isNAK(rcvpkt)`），那么发送端知道接收端接收到的分组是受损的，所以调用 `udt_send(sndpkt)` 重新发送该分组，然后状态不变，继续等待接收接收端的 ACK 或 NAK 分组。

> 　　在上述协议中，当发送方处于等待ACK或NAK状态时，它不能从上层获得更多数据。这样子的协议被称为**停等协议 (stop-and-wait)**。

- rdt 2.0 的接收端仍然只有一个状态。状态变迁取决于收到的分组是否受损，有两种方式：
  - 如果收到的分组受损，即 `rdt_rcv(rcvpkt) && corrupt(rcvpkt)`，则返回 NAK 分组
  - 如果收到的分组完好，即 `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt)`，则返回 ACK 分组
- 处理完后仍然返回自身这个状态，继续等待下一次从底层接收分组并处理。

　　**3.经具有比特差错的丢包信道的可靠数据传输 rdt 3.0**

　　在现实的网络环境中，除了比特受损外，底层信道还会丢包；有很多可能的方法可以解决丢包问题，这里我们让发送方负责检测和恢复丢包工作。

　　假定发送端传输一个数据分组，该分组发生丢失 或者 接收端对该分组的 ACK 发生了丢失。在这两种情况下，发送端都收不到应当到来的接收端的响应。所以，如果发送端愿意等待足够长的时间以确定该分组缺失已丢失，则它只需要重传该数据分组即可。

　　从发送端的观点来看，重传是一个万能灵药。为了实现基于时间的重传机制，需要一个倒数计时器 (countdown timer): 在**一个给定的时间量过期之后，可中断发送方。**发送方需要做到：1）每次发送一个分组（包括第一次分组和重传分组）时，就启动一个定时器；2）相应定时器中断；3）终止定时器。

　　下图是`rdt 3.0`的发送方FSM，该协议运行在可能发生出错和丢失的信道上。

![img](https://img2018.cnblogs.com/blog/226988/201906/226988-20190608162920642-1166593130.png)

　　rdt 2.2 协议中的接收端有限状态机描述图仍然适用于 rdt 3.0 协议，下面我仍然用文字来简要描述一下上图中的发送端发送分组流程：

- 首先由较高层触发 `rdt_send(data)` 事件，通过 `sndpkt = make_pkt(0, data, checksum)` 产生一个序号为 0，包含待发送数据且带有校验和的分组，接着通过 `udt_send(sndpkt)` 将其发送到信道中并启动定时器，然后状态变迁为“等待接收接收端的 ACK 0”
- 当发送端在“等待接收接收端的 ACK 0”的时候：
  - 如果收到了受损的分组（即 `corrupt(rcvpkt)`）或者收到了 ACK 1（即 `isACK(rcvpkt, 1)`，也就是收到了自己发送的上一个分组的 ACK），则直接忽略
  - 如果定时器时间到，则由 `udt_send(sndpkt)` 重新发送该分组并重新启动定时器
  - 如果收到了完好的分组且 ACK 为 0，那么发送端知道接收端已经成功接收了刚才发送的序号为 0 的分组，直接停止定时器，此时发送端状态变迁到等待较高层传下来的数据发送请求
- 注意在继续等待从较高层传下来的数据发送请求的过程中，如果收到了任何分组数据包，都直接忽略，因为它们一定是冗余的

### 流水线可靠数据传输协议

停等协议可能会限制底层网络硬件所提供的能力

解决方法是：不使用停止等待方式，运行发送方发送多个分组而无需等待确认。由于许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，因此这种技术被称为流水线 (pipelining)。当然，流水线会增加协议的复杂度：

- 　必须增加序号范围

　　因为信道中的分组要有一个唯一的序号，会有多个分组在信道中未被确认。

- 协议的发送方和接收方必须缓存多个分组

　　发送方至少应该缓存已经发送却还没有被确认的分组。接受方**也许**应该缓存已经正确接收的分组。

- 所需的序号范围和对缓存大小的要求取决于协议如何处理丢失、损坏及延时大的分组

　　解决流水线差错错误的两种基本思路：回退N步和选择重传。

###  回退N步 GBN

回退N步 GBN 协议被称为滑动窗口协议 (silding-window protocol)

这个协议中，发送方分组被分成四个类型

1. 已发送并已被确认的分组

2. 已发送但还未确认的分组

3. 可用，但还未发送的分组

4. 不可用的分组。

   其中第二种和第三种分组在滑动窗口内。

GBN发送方必须响应三种类型的事件

- 上层的调用
- 收到一个ACK
- 超时事件

回退N步会造成单个分组出错就引起重传大量分组的问题，但许多分组其实没有必要重传，所以可以使用“选择重传”。

### 选择重传 SR

选择重传协议让发送方仅重传那些它怀疑在接收方出错的分组，避免了不需要的重传。

这个协议中，发送方分组也是上面的四个类型，不同的是第一种分组（已发送并已被确认的分组）也会出现在滑动窗口内。

接收方的滑动窗口也有三种类型的分组
 1、失序（已缓存），但未被确认的分组
 2、可接受的分组
 3、期待，还未收到的分组

![](https://upload-images.jianshu.io/upload_images/3629436-42d9dc9acd4aba6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![](https://mmbiz.qpic.cn/mmbiz_jpg/j5D4MI5U9vX67Ziaria9ibcMMNVR5Gn2zUFPbJaxr30iaNze41BbOphdpYDGN7TLqGA48nt7x9FnkOvcTA5msDuJow/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 面向连接的运输 TCP

TCP的“三次握手”中，前两次的报文段不承载“有效载荷”，也就是不包含应用层数据，第三次报文段可以承载有效载荷。

TCP连接的组成包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。在这两台主机之间的网络元素（路由器、交换机和中继器）中，没有为该连接分配任何缓存和变量。

TCP为每块客户数据配上一个TCP首部,从而形成了多个**TCP报文段**. 这些报文段被下传给网络层,网络层将其分别封装在网路层IP数据报中. 接着数据包被发送到网络中. 当TCP在另一端接收到一个报文段后,该报文段的数据就被放入该TCP连接的接收缓存中. 

### TCP报文段结构

![](https://upload-images.jianshu.io/upload_images/3629436-3a605f7a79d93ced.png?imageMogr2/auto-orient/strip|imageView2/2/w/824/format/webp)

- 源端口号和目的端口号：用于多路复用/分解
- 序号和确认号：被TCP发送方和接收方用来实现可靠数据传输服务
- 接收窗口：用于流量控制。指示接收方愿意接受的字节数量。
- 首部长度：由于TCP选项字段，TCP首部的长度是可变的。（通常，选项字段为空，所以TCP首部的典型长度就是20字节）
- 选项：用于发送方和接收方协商最大报文段长度(MSS)时，或在高速网络环境下用作窗口调节因子时使用
- 6比特的标志字段：ACK(成功接受报文段的确认)、RST-SYN-FIN(用于TCP连接的建立和拆除)、PSH(接收方应立即把数据交给上层)、URG(略)



### SYN洪泛攻击

这种攻击针对的是TCP的“三次握手”。

在正常的三次握手中，服务器为了响应一个收到的SYN，分配并初始化连接变量和缓存。然后服务器发送一个SYN ACK进行响应，并等待来自客户的ACK报文段。如果某客户不发送ACK来完成该三次握手的第三步，最终（通常在一分多钟之后）服务器将终止该半开连接并回收资源。

在SYN洪泛攻击中，攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤。随着这种SYN报文段纷至沓来，服务器不断为这些半开连接分配资源（但从未使用），导致服务器的连接资源被消耗殆尽。

有效应对SYN洪泛攻击的防御系统称为SYN cookie。



### 丢包检测与恢复

- TCP提供**定时器超时**和**冗余ACK**两种丢包检测机制（冗余ACK也可表征包错误）
- 相应地，TCP提供**超时重传**和**快速重传**两种丢包恢复机制（快速重传也可恢复包错误）

### TCP超时机制

- TCP需要超时重传机制以处理报文段的丢失。
  一个重要的问题是如何设置超时间隔的长度。
  RTT可以作为超时间隔长度设置的一个重要参考。



### TCP差错恢复机制——回退N步与选择重传

首先，我们需要明白的是，**TCP采用了累计确**认的机制，也就说，如果接收方正确接收了某一失序到达的分组，那么接收方发送的ACK将是对最后接收的按序到达的分组的确认，而不是对刚刚接收的分组的确认；当然，许多TCP实现都会缓存失序的分组；那么问题来了，发生超时事件后，GBN将重传所有待确认的分组，而不是丢失的分组；而选择重传会好很多

对TCP提出的一种修改意见是所谓的选择确认——即接收方对失序到达的分组也会确认，当该机制和重传机制相结合使得TCP更像选择重传，于是TCP的差错恢复协议最好被分类为GBN和SR协议的混合体.

- TCP使用累积确认技术，正确接收但失序的报文段不会被接收方逐个确认，对报文段i的确认代表i之前的所有报文都已正确接收。
- 基于累积确认，TCP发送方仅需维护已发送但未被确认的最小序号和下一个待发送字节的序号即可。
- 大多数TCP实现会将正确接收但失序的报文段缓存起来。当报文i的ACK超时后，TCP不会依照回退N步的策略将报文段i，i+1.....N都重传，而是只重传报文段i。
- TCP的差错恢复机制是回退N步与选择重传的结合。

### 流量控制

流量控制是一个**速度匹配**服务：TCP连接的发送方和接收方都各自维护一个缓存，因此两者的数据交换应该在一个合理的速度范围内：不让对方发生数据溢出；TCP为它的应用程序提供了这种服务：流量控制服务。虽然流量控制和拥塞控制所采取的动作非常相似，但是它们的目的很明显并不同。在接下来的讨论中，我们将假设TCP是这样实现的，即TCP接收方丢弃失序到达的报文段

在TCP首部中有一个**窗口大小**字段，TCP连接的双方通过该字段来向对方表明自己的窗口大小，即缓存空间的大小；同样，在TCP连接的两端，各自维护着相关的变量：**last Sent、last Acked**；在发送方，这两个变量之间的分组就是**已经发送但是尚未确认的分组**；而在接收方，**last Read**表示应用进程下一次读取的数据，**last Revd**表示最后纳入缓存的报文段编号（注意，我们讨论的前提是TCP会将失序到达的报文段丢弃哦~）；通过这些变量以及报文段首部中窗口大小字段，我们就可以对发送速度做一些控制：在发送方**last Sent-last Acked应该小于等于接收方的窗口大小**；在接收端**A=last Received - last Read就是已经使用的空间大小，所以窗口大小=buffer - A**；

对了，还有一个问题就是，如果接收方的窗口大小为0，那么发送端该如何处理呢？一个需要注意的事实是，接收方在没有ACK或者数据要向发送端发送的时候，是不会通知发送方其窗口大小已经改变，即如果应用程序读取了缓存中的数据，发送方是不会知道的，除非它向接收方发送了数据，而发送方对其进行了确认；实际上，发送方也是这么做的！当接收到窗口大小为0的报文段后，发送方会向接收方间隔发送只有一个字节的数据。

### ==三次握手==

握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器端也结束CLOSED阶段，并进入LISTEN阶段。随后开始“三次握手”：

1. 首先客户端向服务器端发送一段TCP报文，其中：
   1. 标记位SYN(就是ACK=1)，表示“请求建立新连接”;序号为Seq=X（X一般为1）；随后客户端进入SYN-SENT阶段。
2. 服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：
   1. 标志位为SYN和ACK(就是ACK=1,SYN=1)，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；序号为Seq=y；确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；随后服务器端进入SYN-RCVD阶段。

3. 客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：
   1. 标志位为ACK(就是ACK=1)，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；随后客户端进入ESTABLISHED阶段。服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-SENT阶段，进入ESTABLISHED阶段。

在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续"握手"，以此确保了"三次握手"的顺利完成。

**TCP 协议规定SYN报文虽然不携带数据， 但是也要消耗1个序列号， 所以前两次握手客户端和服务端都需要向对方回复 x+1 或 y+1 。**

![](https://wx1.sbimg.cn/2020/08/27/6GdT2.md.png)

此后客户端和服务器端进行正常的数据传输。这就是“三次握手”的过程。

![](https://pics1.baidu.com/feed/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg?token=c86d4509157378798ebbccbe843486d1&s=9746F8123F5754CA48D574DA0300D0B2)



**三次握手动态实现过程**

![动态实现过程](https://wx1.sbimg.cn/2020/07/25/DSM6U.gif)

**为什么进行三次握手**

为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。

- 客户端发送请求给服务端时的错误
  - 若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。

### ==TCP的四次挥手（Four-Way Wavehand）==

所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。

我们知道，TCP连接是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。

![](https://pics5.baidu.com/feed/48540923dd54564e5260495ce0006487d0584fb6.jpeg?token=c3a743af38e25ff66deb6a07891be58e&s=C584FC1A71CFF4EE1A75A45203007073)

1. 首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：

   1. 标记位为FIN，表示“请求释放连接“；
   2. 序号为Seq=U；
   3. 随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。

   注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。

2. 服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：

   1. 标记位为ACK，表示“接收到客户端发送的释放连接的请求”；
   2. 序号为Seq=V；
   3. 确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；

   随后服务器端开始准备释放服务器端到客户端方向上的连接。客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段

   前"两次挥手"既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了

3. 服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：

   1. 标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。
   2. 序号为Seq=W；
   3. 确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。

   随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。

4. 客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：

   1. 标记位为ACK，表示“接收到服务器准备好释放连接的信号”。
   2. 序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。
   3. 确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。

   随后客户端开始在TIME-WAIT阶段等待2MSL



服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器端到客户端方向上的连接。

客户端等待完2MSL之后(确认服务器端是否收到客户端发出的ACK确认报文)，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”。

后“两次挥手”既让客户端知道了服务器端准备好释放连接了，也让服务器端知道了客户端了解了自己准备好释放连接了。于是，可以确认关闭服务器端到客户端方向上的连接了，由此完成“四次挥手”。

与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续"挥手"，以此确保了"四次挥手"的顺利完成。



==为什么“握手”是三次，“挥手”却要四次？==

TCP建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。

即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。

TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次"握手"传输的。**为何建立连接时一起传输，释放连接时却要分开传输？**

- 建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。

- 释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。

  - 保证客户端发送的最后一个ACK报文段能够到达服务端。
    - 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。

  - 防止“已失效的连接请求报文段”出现在本连接中。
    - 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

## 拥塞控制原理

### 拥塞原因与代价

计算机网络拥塞的原因是因为网络中的分组太多，而链路带宽和路由器缓存容量都是有限的；

-   当分组的到达速率接近链路容量时，分组将经历巨大的排队时延；
-   发送方必须执行重传已补偿因为缓存溢出而丢弃的分组
-   发送方遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。
-   当一个分组沿着一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了；

###  拥塞控制方法

#### ==拥塞控制和流量控制==

- 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；
- 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收。

总体来说，我们可以根据网络层是否为传输层拥塞控制提供了显式帮助来区分拥塞控制方法：**端到端拥塞控制和网络辅助拥塞控制**；

#### **端到端拥塞控制**

此方法中，网络层并没有向传输层拥塞控制提供显式支持，即便网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来判断；

TCP必须通过端到端的方法解决拥塞控制，因为**IP层不会像端系统提供有关网络拥塞的反馈信息**。TCP报文段的丢失（超时或者收到3次冗余确认而得知）被认为是网络拥塞的一个迹象，TCP将相应地减小窗口长度；

#### **网络辅助的拥塞控制**

此方法里，网络层会向发送方提供关于网络中拥塞状态的显式反馈消息；

比如使用一个比特位来指示网络是否拥塞；

拥塞信息从网络反馈到发送方一般有两种方式

1. 其中直接反馈信息可以由网络路由器发送给发送方，这种方式的通知通常采用一种拥塞分组的形式；
2. 第二种形式的通知是路由器标记或者更新从发送方到接收方的分组中的某个字段来指示拥塞的产生，然后由接收方向发送方通知该网络发生了拥塞。

###  网络辅助的拥塞控制例子：ATM ABR拥塞控制 异步传输方式 可用比特率

ATM基本上采用一种面向虚电路的方法来处理分组交换。

ABR已被设计成一种弹性数据传输服务。

对于ATM ABR服务，数据信元经过一系列交换机传输到目的地。在数据信元中夹杂着所谓的资源管理信元（RM信元）。这些RM信元可被用作在主机和交换机之间传递与堵塞相关的消息。当一个RM信源到达目的地时，它将掉头并向发送端发送。交换机也可能自己产生一个RM信元，并将该信元直接发送给源。因此，RM信元可以用来提供直接网络反馈和经由接收方的网络反馈。

与拥塞相关的信令信息：

1. EFCI比特。每个数据信元都包含一比特的**显式转发拥塞指令（EFCI）。**某拥塞的网络交换机可把一个数据信元中的EFCI设为1来向目的主机发送网络已经堵塞的信令。当一个RM到达时，如果多数近来收到的数据信元的EFCI都是1.则目的地会将RM的堵**塞指示比特**（CI）设为1，并将RM信元发送给发送方。
2. CI和NI比特。RM信元的夹杂比率可调。每个RM信元包含一个拥塞指示比特（CI）和无增长比特（NI）。轻微堵塞NI设1，严重堵塞CI设1.
3. ER的设置。每一个RM信元还包含一个两个字节的显式速率（ER）字段。一个拥塞的交换机也许会降低ER的值。ER字段被设置为在源和目的路径上所有交换机中的最小可支持速率。

## TCP拥塞控制原理

==**TCP必须使用端到端的拥塞控制而不是网络辅助的拥塞控制**==，因为IP并不会向端系统提供显式的网络拥塞反馈；TCP所采用的方法是让每一个发送方根据其所感知的网络拥塞程度来限制其能向连接发送流量的速率；如果TCP判断网络通畅，那么它会提高发送速率，如果TCP判断网络拥塞，那么它会限制发送速率；需要解决三个问题：TCP如何限制发送速率？TCP如何感知网络拥塞程度？TCP该以何种算法改变其发送速率？

我们知道，TCP连接的双方都维护着两个窗口，其中一个是作为发送方的窗口，也被称为**拥塞窗口**cwnd，它对发送方能向网络中发送流量的速率进行了限制，last sent-last acked<=min{cwnd,rwnd}；另一个自然是作为接收方的接收窗口。

我们假设，发送方可以在RTT时间范围内连续发送cwnd个字节的数据，所以发送速率即为cwnd/RTT；发送方通过调整窗口大小来对发送数据的速率加以控制

==我们将TCP发送方的丢包事件定义为：要么**超时**，要么收到接收方的**3个冗余ACK**；==

如果网路拥塞，那么网络中的路由器就会发生缓存溢出，进而导致数据报被丢弃，然后就会引起发送方的丢包事件；此时，TCP发送方就可以认为TCP连接出现了拥塞

另外，TCP将接收方发送的ACK视为网络通畅的标志，如果ACK到达的速率较高，那么TCP的拥塞窗口就会以较高的速率扩大，如果ACK到达的速率较慢，那么TCP拥塞窗口的增加速度也会较慢；因为TCP使用ACK对拥塞窗口做出调节，所以也别称为**自计时**的；

TCP发送速率过高，网络就很容易拥塞；TCP发送方如果过于谨慎，那么就无法充分利用网络的带宽；所以TCP如何设置自己的发送速率，才能使得网络不会拥塞而且还充分利用带宽呢？关于这个问题，TCP使用下列指导性原则回答这些问题：

  一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率；
  一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当收到对先前报文段的确认时，可以增加发送方的速率；
  带宽检测；TCP调节器传输速率的策略是增加其速率以响应到达的ACK，除非出现丢包，此时才减少发送速率；以为网络中没有明确的拥塞控制状态信令，ACK和丢包事件充当了隐式信号.

以上为TCP拥塞控制的概述，接下来就是广受赞誉的TCP拥塞控制算法，该算法包含三个主要部分：**慢启动、拥塞避免、快速恢复；**慢启动和拥塞控制是TCP的强制部分；两者的差异在于对收到的ACK做出反应时增加cwnd长度的方式；快速恢复是推荐部分，对于TCP发送方并非是必须的

**1.慢启动**

TCP连接在开始的时候，其cwnd常设置为一个MSS，然后在慢启动状态每收到一个ACK，cwnd就增加一个MSS；这样的话，在慢启动阶段，发送速率是指数增加的（1,2,4,8…）

何时结束这种指数增长？有三种情况：发送了超时、发生了冗余ACK以及cwnd达到ssthresh。**ssthresh是慢启动阈值的速记**；在慢启动阶段，如果发生了超时事件，那么ssthresh就被设置为当前cwnd的一半，然后将cwnd置为1；当cwnd逐步增加到ssthresh时，再翻倍增加cwnd就有一点鲁莽了，所以此时TCP结束慢启动，进入拥塞避免模式。在拥塞避免模式里，TCP将更谨慎地增加cwnd；如果收到冗余ACK，那么TCP会做一次快速重传，然后进入快速恢复阶段；

**2.拥塞避免**

一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的一半，所以TCP在每个RTT中，只将cwnd增加一个1个MSS大小；也就是说在拥塞避免阶段，cwnd是线性增加的；

当出现超时时，将ssthresh更新为cwnd的一半, cwnd置为1；当收到冗余ACK时，TCP将cwnd减半，然后将ssthresh置为cwnd值的一半，并且进入快速恢复状态；

**3.快速恢复**

在快速恢复阶段，对于引起TCP进入该状态的缺失报文段，每收到一个ACK，cwnd增加一个MSS；最终，当对丢失报文段的一个ACK到达时，TCP降低cwnd后进入拥塞避免状态；如果出现超时事件，快速恢复在执行如同慢启动和拥塞避免中相同动作后，进入慢启动状态.
![]( https://img-blog.csdnimg.cn/20190731184935595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

# ![img](https://img-blog.csdnimg.cn/20190325133948229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70)

当多条连接共享一条瓶颈链路时，那些具有较小RTT的连接能够在链路空闲时更快的抢到可用带宽（即较快的打开其拥塞窗口），因而将比那些具有较大RTT的连接享用更高的吞吐量。